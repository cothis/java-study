/*
    Join
    둘 이상의 테이블을 연결해서 데이터를 검색하는 방법
    보통 두 개이상의 행들의 공통된 값 primary key(기본키), foreign key(외래키)
    을 사용해서 연결한다.

    Primary key(기본키) : 테이블에서 중복되지 않는 키
    Foreign key(외래키) : 다른 테이블에 있는 키

    Ansi SQL 문법
    Oracle 문법

    Inner Join : *****
    Full Outer Join
    Cross Join
    Left Outer Join : ***
    Right Outer Join : ***
    Self Join : *****
*/

-- Inner Join
-- Ansi SQL 문법
SELECT E.EMPLOYEE_ID, E.FIRST_NAME, D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E
         INNER JOIN DEPARTMENTS D on D.DEPARTMENT_ID = E.DEPARTMENT_ID;

-- Oracle 문법
SELECT E.EMPLOYEE_ID, E.FIRST_NAME, D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID


-- Full Outer Join
-- Ansi SQL 문법
SELECT E.EMPLOYEE_ID, E.FIRST_NAME, D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E FULL OUTER JOIN DEPARTMENTS D on E.DEPARTMENT_ID = D.DEPARTMENT_ID

-- Oracle 문법 (크로스 조인, Full Outer 아님!)
SELECT E.EMPLOYEE_ID, E.FIRST_NAME, D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D

-- Left Outer Join
-- Ansi SQL 문법
SELECT E.EMPLOYEE_ID, E.FIRST_NAME, D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E LEFT OUTER JOIN DEPARTMENTS D on E.DEPARTMENT_ID = D.DEPARTMENT_ID

-- Oracle 문법
SELECT E.EMPLOYEE_ID, E.FIRST_NAME, D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID(+)
-- + 가 있는 쪽에서 없는쪽으로 간다 (LEFT)

-- Left Outer Join without inner Join
SELECT E.EMPLOYEE_ID, E.FIRST_NAME, D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID(+)
  AND E.DEPARTMENT_ID IS NULL;


-- Self Join : 동일한 테이블 Join
SELECT A.EMPLOYEE_ID, A.FIRST_NAME, A.MANAGER_ID, B.EMPLOYEE_ID, B.FIRST_NAME
FROM EMPLOYEES A, EMPLOYEES B -- A:사원, B:상사번호
WHERE A.MANAGER_ID = B.EMPLOYEE_ID;

SELECT A.EMPLOYEE_ID, A.FIRST_NAME, A.MANAGER_ID, B.EMPLOYEE_ID, B.FIRST_NAME
FROM EMPLOYEES A
         INNER JOIN EMPLOYEES B ON A.MANAGER_ID = B.EMPLOYEE_ID;

-- 계층형 구조 오름, 내림
SELECT A.EMPLOYEE_ID, LPAD(' ', (LEVEL-1)*2) || A.FIRST_NAME, A.MANAGER_ID, B.EMPLOYEE_ID, B.FIRST_NAME
FROM EMPLOYEES A, EMPLOYEES B
WHERE A.MANAGER_ID = B.EMPLOYEE_ID(+)
CONNECT BY PRIOR A.MANAGER_ID = A.EMPLOYEE_ID -- 상향식

SELECT A.EMPLOYEE_ID, LPAD(' ', (LEVEL-1)*2) || A.FIRST_NAME, A.MANAGER_ID, B.EMPLOYEE_ID, B.FIRST_NAME
FROM EMPLOYEES A, EMPLOYEES B
WHERE A.MANAGER_ID = B.EMPLOYEE_ID(+)
CONNECT BY A.MANAGER_ID = PRIOR A.EMPLOYEE_ID -- 하향식

select Count(MANAGER_ID) from EMPLOYEES;
select Count(*) from EMPLOYEES
where MANAGER_ID is not null;

